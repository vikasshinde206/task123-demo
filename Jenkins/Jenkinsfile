def isReleaseBranch = { env.BRANCH_NAME ==~ /release\/.*/ }

pipeline {
  agent none

  environment {
    IMAGE = "clients-api"
  }

  options {
    skipStagesAfterUnstable()
    timestamps()
  }

  stages {
    stage('Checkout') {
      when { expression { isReleaseBranch() } }
      agent any
      steps {
        echo "Checking out code from ${env.BRANCH_NAME}..."
        checkout scm
      }
    }

    stage('Build') {
      when { expression { isReleaseBranch() } }
      agent {
        docker {
          image 'maven:3.9.9-eclipse-temurin-17'
          args '-v $HOME/.m2:/root/.m2'
        }
      }
      steps {
        echo "Building Maven project..."
        sh 'mvn clean package -DskipTests'
      }
    }

    stage('Unit Test') {
      when { expression { isReleaseBranch() } }
      agent {
        docker {
          image 'maven:3.9.9-eclipse-temurin-17'
          args '-v $HOME/.m2:/root/.m2'
        }
      }
      steps {
        echo "Running unit tests..."
        sh 'mvn test'
      }
      post {
        always {
          junit '**/target/surefire-reports/*.xml'
        }
      }
    }

    stage('Trivy Security Scan') {
      when { expression { isReleaseBranch() } }
      agent {
        docker {
          image 'aquasec/trivy:latest'
        }
      }
      steps {
        echo "Running Trivy security scan..."
        sh '''
          trivy image --exit-code 1 --severity HIGH,CRITICAL --format table -o trivy-report.txt $IMAGE:${GIT_COMMIT::7} || true
        '''
      }
      post {
        always {
          archiveArtifacts artifacts: 'trivy-report.txt', allowEmptyArchive: true
        }
      }
    }

    stage('Build & Push to ECR') {
      when { expression { isReleaseBranch() } }
      agent {
        docker {
          image 'amazon/aws-cli:2.15.0'
          args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
      }
      environment {
        REGISTRY = credentials('ecr-registry')
        AWS_REGION = credentials('aws-region')
      }
      steps {
        echo "Building and pushing Docker image to ECR..."
        withCredentials([usernamePassword(credentialsId: 'ecr-creds', usernameVariable: 'AWS_ACCESS_KEY_ID', passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            echo "Logging into AWS ECR..."
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $REGISTRY

            echo "Building and pushing Docker image..."
            docker build -t $REGISTRY/$IMAGE:${GIT_COMMIT::7} .
            docker push $REGISTRY/$IMAGE:${GIT_COMMIT::7}
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
	  when { expression { isReleaseBranch() } }
	  agent {
		docker {
		  image 'bitnami/kubectl:1.30'
		}
	  }
	  environment {
		REGISTRY = credentials('ecr-registry')
		AWS_REGION = credentials('aws-region')
		KUBE_NAMESPACE = credentials('kube-namespace')
	  }
	  steps {
		script {
		  echo "Deploying to Kubernetes namespace: $KUBE_NAMESPACE ..."
		  withCredentials([file(credentialsId: 'kubeconfig-cred', variable: 'KUBECONFIG_FILE')]) {
			try {
			  sh '''
				set -e
				export KUBECONFIG=$KUBECONFIG_FILE

				echo "Updating deployment image..."
				kubectl set image deployment/clients-api clients-api=$REGISTRY/$IMAGE:${GIT_COMMIT::7} -n $KUBE_NAMESPACE

				echo "Waiting for rollout to complete..."
				kubectl rollout status deployment/clients-api -n $KUBE_NAMESPACE --timeout=180s

				echo "Deployment completed successfully!"
			  '''
			  currentBuild.result = 'SUCCESS'
			} catch (err) {
			  echo "Deployment failed! Rolling back..."
			  sh '''
				export KUBECONFIG=$KUBECONFIG_FILE
				kubectl rollout undo deployment/clients-api -n $KUBE_NAMESPACE || true
			  '''
			  error("Deployment to Kubernetes failed. Pipeline aborted.")
			}
		  }
		}
	  }
	}

  }

  post {
    success {
      echo "Pipeline completed successfully for ${env.BRANCH_NAME}"
    }
    failure {
      echo "Pipeline failed for ${env.BRANCH_NAME}"
    }
  }
}
